{"ast":null,"code":"import { of } from 'rxjs';\nimport { WorkStatus } from '../enums/workStatus.enum';\nimport * as i0 from \"@angular/core\";\nexport class TaskService {\n  constructor() {\n    this.localStorageKey = 'tasks';\n    this.tasks = [];\n    this.getDataFromLocalStorage();\n  }\n  getDataFromLocalStorage() {\n    const data = localStorage.getItem(this.localStorageKey);\n    if (data) this.tasks = JSON.parse(data);\n  }\n  saveDataToLocalStorage() {\n    localStorage.setItem(this.localStorageKey, JSON.stringify(this.tasks));\n  }\n  getTasks() {\n    return of(this.tasks);\n  }\n  getSingleTask(ID) {\n    const task = this.tasks.find(task => task.ID === ID);\n    if (task) {\n      return of(task);\n    } else {\n      throw new Error('Task not found');\n    }\n  }\n  createTask(task) {\n    const taskCopy = {\n      ...task\n    }; // Tworzymy kopię obiektu zadania\n    const functionalityCopy = {\n      ...taskCopy.functionality\n    }; // Tworzymy kopię obiektu funkcjonalności\n    taskCopy.functionality = functionalityCopy; // Przypisujemy skopiowany obiekt funkcjonalności do zadania\n    this.tasks.push(taskCopy);\n    this.saveDataToLocalStorage();\n    return of(taskCopy);\n  }\n  deleteTask(ID) {\n    const index = this.tasks.findIndex(task => task.ID === ID);\n    if (index !== -1) {\n      const deletedTask = this.tasks.splice(index, 1)[0];\n      const functionality = deletedTask.functionality;\n      if (functionality && functionality.tasks) {\n        const taskIndex = functionality.tasks.findIndex(task => task.ID === ID);\n        if (taskIndex !== -1) {\n          functionality.tasks.splice(taskIndex, 1);\n        }\n        // Sprawdź status funkcjonalności po usunięciu zadania\n        this.updateFunctionalityStatus(functionality);\n      }\n      this.saveDataToLocalStorage();\n      return of(true);\n    } else {\n      return of(false);\n    }\n  }\n  updateTask(task) {\n    const taskToUpdate = this.tasks.find(t => t.ID === task.ID);\n    if (taskToUpdate) {\n      taskToUpdate.name = task.name;\n      taskToUpdate.description = task.description;\n      taskToUpdate.priority = task.priority;\n      taskToUpdate.state = task.state;\n      taskToUpdate.addedDate = task.addedDate;\n      taskToUpdate.startDate = task.startDate;\n      taskToUpdate.endDate = task.endDate;\n      taskToUpdate.assignedUser = task.assignedUser;\n      taskToUpdate.functionalityID = task.functionalityID; // Aktualizacja pola functionalityID\n      taskToUpdate.functionality = task.functionality; // Aktualizacja pola functionality\n      this.saveDataToLocalStorage();\n      return of(taskToUpdate);\n    } else {\n      throw new Error('Task not found');\n    }\n  }\n  // Dodaj tę funkcję do aktualizacji statusu funkcjonalności\n  updateFunctionalityStatus(functionality) {\n    const hasDoingTask = functionality.tasks?.some(task => task.state === WorkStatus.Doing);\n    const allTasksDone = functionality.tasks?.every(task => task.state === WorkStatus.Done);\n    if (hasDoingTask) {\n      functionality.status = WorkStatus.Doing;\n    } else if (allTasksDone) {\n      functionality.status = WorkStatus.Done;\n    }\n  }\n}\nTaskService.ɵfac = function TaskService_Factory(t) {\n  return new (t || TaskService)();\n};\nTaskService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: TaskService,\n  factory: TaskService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["of","WorkStatus","TaskService","constructor","getDataFromLocalStorage","data","localStorage","getItem","localStorageKey","tasks","JSON","parse","saveDataToLocalStorage","setItem","stringify","getTasks","getSingleTask","ID","task","find","Error","createTask","taskCopy","functionalityCopy","functionality","push","deleteTask","index","findIndex","deletedTask","splice","taskIndex","updateFunctionalityStatus","updateTask","taskToUpdate","t","name","description","priority","state","addedDate","startDate","endDate","assignedUser","functionalityID","hasDoingTask","some","Doing","allTasksDone","every","Done","status","factory","providedIn"],"sourceRoot":"","sources":["/Users/haze/Desktop/Angular Final Project/angularFinalProject/src/app/services/task.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { TaskInterface } from '../interfaces/task.interface';\nimport { FunctionalityInterface } from '../interfaces/functionality.interface';\nimport { Observable, of } from 'rxjs';\nimport { WorkStatus } from '../enums/workStatus.enum';\n@Injectable({\n  providedIn: 'root',\n})\nexport class TaskService {\n  private localStorageKey = 'tasks';\n  private tasks: TaskInterface[] = [];\n\n  constructor() {\n    this.getDataFromLocalStorage();\n  }\n\n  private getDataFromLocalStorage(): void {\n    const data = localStorage.getItem(this.localStorageKey);\n    if (data) this.tasks = JSON.parse(data);\n  }\n\n  private saveDataToLocalStorage(): void {\n    localStorage.setItem(this.localStorageKey, JSON.stringify(this.tasks));\n  }\n\n  getTasks(): Observable<TaskInterface[]> {\n    return of(this.tasks);\n  }\n\n  getSingleTask(ID: string): Observable<TaskInterface> {\n    const task = this.tasks.find((task) => task.ID === ID);\n\n    if (task) {\n      return of(task);\n    } else {\n      throw new Error('Task not found');\n    }\n  }\n\n  createTask(task: TaskInterface): Observable<TaskInterface> {\n    const taskCopy = { ...task }; // Tworzymy kopię obiektu zadania\n    const functionalityCopy = { ...taskCopy.functionality }; // Tworzymy kopię obiektu funkcjonalności\n    taskCopy.functionality = functionalityCopy; // Przypisujemy skopiowany obiekt funkcjonalności do zadania\n    this.tasks.push(taskCopy);\n    this.saveDataToLocalStorage();\n    return of(taskCopy);\n  }\n  deleteTask(ID: string): Observable<boolean> {\n    const index = this.tasks.findIndex((task) => task.ID === ID);\n\n    if (index !== -1) {\n      const deletedTask = this.tasks.splice(index, 1)[0];\n      const functionality = deletedTask.functionality;\n\n      if (functionality && functionality.tasks) {\n        const taskIndex = functionality.tasks.findIndex(\n          (task) => task.ID === ID\n        );\n        if (taskIndex !== -1) {\n          functionality.tasks.splice(taskIndex, 1);\n        }\n\n        // Sprawdź status funkcjonalności po usunięciu zadania\n        this.updateFunctionalityStatus(functionality);\n      }\n\n      this.saveDataToLocalStorage();\n      return of(true);\n    } else {\n      return of(false);\n    }\n  }\n\n  updateTask(task: TaskInterface): Observable<TaskInterface> {\n    const taskToUpdate = this.tasks.find((t) => t.ID === task.ID);\n\n    if (taskToUpdate) {\n      taskToUpdate.name = task.name;\n      taskToUpdate.description = task.description;\n      taskToUpdate.priority = task.priority;\n      taskToUpdate.state = task.state;\n      taskToUpdate.addedDate = task.addedDate;\n      taskToUpdate.startDate = task.startDate;\n      taskToUpdate.endDate = task.endDate;\n      taskToUpdate.assignedUser = task.assignedUser;\n      taskToUpdate.functionalityID = task.functionalityID; // Aktualizacja pola functionalityID\n      taskToUpdate.functionality = task.functionality; // Aktualizacja pola functionality\n      this.saveDataToLocalStorage();\n      return of(taskToUpdate);\n    } else {\n      throw new Error('Task not found');\n    }\n  }\n\n  // Dodaj tę funkcję do aktualizacji statusu funkcjonalności\n  private updateFunctionalityStatus(functionality: FunctionalityInterface) {\n    const hasDoingTask = functionality.tasks?.some(\n      (task) => task.state === WorkStatus.Doing\n    );\n    const allTasksDone = functionality.tasks?.every(\n      (task) => task.state === WorkStatus.Done\n    );\n\n    if (hasDoingTask) {\n      functionality.status = WorkStatus.Doing;\n    } else if (allTasksDone) {\n      functionality.status = WorkStatus.Done;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}